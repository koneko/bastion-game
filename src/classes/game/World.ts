import { BSON } from 'bson';
import { CellType, Engine, ExportCell, ExportProp } from '../../Constants';
import { Container, Text, TextStyle, Sprite, AnimatedSprite } from 'pixi.js';
import GameAssets from '../../GameAssets';

class Prop {
    public animated: boolean;
    private sprite: Sprite | AnimatedSprite;
    constructor(prop: ExportProp, parent: Container, x: number, y: number) {
        this.animated = prop.animated;
        const cellSize = Engine.GridCellSize * Engine.GridUpscale;
        const snappedX = x * cellSize;
        const snappedY = y * cellSize;
        if (this.animated) {
            const textures = [];
            prop.animationTextures.forEach((num) => {
                textures.push(GameAssets.WorldTextures[prop.propTexture].textures[num]);
            });
            this.sprite = new AnimatedSprite(textures);
            (this.sprite as AnimatedSprite).animationSpeed = 0.25;
            (this.sprite as AnimatedSprite).play();
        } else {
            this.sprite = new Sprite(GameAssets.WorldTextures[prop.propTexture].textures[prop.propTextureIndex]);
        }
        this.sprite.position.set(snappedX, snappedY);
        this.sprite.height = cellSize;
        this.sprite.width = cellSize;
        parent.addChild(this.sprite);
    }
}

export class Cell {
    public x: number;
    public y: number;
    public type: CellType;
    public props: Prop[] = [];
    private sprite: Sprite;
    constructor(cell: ExportCell, parent: Container) {
        this.x = cell.x;
        this.y = cell.y;
        this.type = cell.type;

        const cellSize = Engine.GridCellSize * Engine.GridUpscale;
        const snappedX = cell.x * cellSize;
        const snappedY = cell.y * cellSize;
        this.sprite = new Sprite(
            GameAssets.WorldTextures[cell.backgroundTexture].textures[cell.backgroundTextureIndex]
        );
        this.sprite.position.set(snappedX, snappedY);
        this.sprite.height = cellSize;
        this.sprite.width = cellSize;
        parent.addChild(this.sprite);

        cell.props.forEach((p) => {
            this.props.push(new Prop(p, parent, this.x, this.y));
        });
    }
}

export default class World {
    /**
     * Contains the visuals of each cell.
     */
    public container: Container = new Container();

    /**
     * Array of each cell generated by the constructor.
     */
    public cells: Cell[] = [];

    /**
     * Loads and exposes world from .bastion file
     * @param {string} mapFileURL
     * @returns {World}
     */
    constructor(mapFileURL: string) {
        if (!mapFileURL.endsWith('.bastion')) {
            console.error('Map loading error. URL does not end with .bastion');
            console.error('URL param: ' + mapFileURL);
            return;
        }
        Engine.currentScene.stage.addChild(this.container);
        const text = new Text({
            text: 'Building world. Please wait.',
            style: new TextStyle({
                fill: 0xffffff,
                fontSize: 50,
            }),
        });
        text.x = Engine.app.canvas.width / 2;
        text.y = Engine.app.canvas.height / 2 + 50;
        text.anchor.set(0.5, 0.5);
        Engine.app.stage.addChild(text);

        fetch(mapFileURL)
            .then((res) => res.arrayBuffer())
            .then((content) => {
                try {
                    const uint8array = new Uint8Array(content);
                    const decoded = BSON.deserialize(uint8array);
                    const importCells: ExportCell[] = decoded.cells;
                    importCells.forEach((c) => {
                        this.cells.push(new Cell(c, this.container));
                    });
                    text.destroy();
                } catch (e) {
                    alert('Map load error. Check console.');
                    console.error(e);
                }
            });
    }
    public GetCellsByType(type: CellType) {
        return this.cells.filter((c) => c.type == type);
    }
}
